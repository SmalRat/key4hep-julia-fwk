using Graphs

function mockup_function(data::Vector)
    push!(data, 0) # so data is never empty
    result = sum(fetch, data)
    result += 1
    return result
end

function wrapper(data::Vector, vertex_id)
    resulting_data = mockup_function(data)
    # println("Vertex $vertex_id processed with resulting_data: $resulting_data")
    return resulting_data
end

function get_ine_map(G)
    incoming_edges_sources_map = Dict{eltype(G), Vector{eltype(G)}}()

    for edge in Graphs.edges(G)
        src_vertex = src(edge)
        dest_vertex = dst(edge)
        
        if haskey(incoming_edges_sources_map, dest_vertex)
            push!(incoming_edges_sources_map[dest_vertex], src_vertex)
        else
            incoming_edges_sources_map[dest_vertex] = [src_vertex]
        end
    end

    return incoming_edges_sources_map
end

function get_deps_promises(vertex_id, map, G)
    incoming_data = []
    if haskey(map, vertex_id)
        for src in map[vertex_id]
            push!(incoming_data, get_prop(G, src, :res_data))
        end
    end
    return incoming_data
end

function parse_graphml(path)
    file_path = joinpath(path...)
    G = GraphMLReader.loadgraphml(file_path, "G")
end

function show_graph(G)
    for (_, v) in enumerate(Graphs.vertices(G))
        println("Node: ")
        print("Node type: ")
        println(get_prop(G, v, :type))
        print("Node class (only for algorithms): ")
        println(get_prop(G, v, :class))
        print("Original name: ")
        println(get_prop(G, v, :original_id))
        print("Node name: ")
        println(get_prop(G, v, :node_id))
        println()
    end
end

function configure_webdash_multievent()
    ctx = Dagger.Sch.eager_context()
    ml = Dagger.TimespanLogging.MultiEventLog()

    TimespanLogging = Dagger.TimespanLogging
    ## Add some logging events of interest

    ml[:core] = TimespanLogging.Events.CoreMetrics()
    ml[:id] = TimespanLogging.Events.IDMetrics()
    ml[:timeline] = TimespanLogging.Events.TimelineMetrics()
    # ...

    # (Optional) Enable profile flamegraph generation with ProfileSVG
    ml[:profile] = DaggerWebDash.ProfileMetrics()
    ctx.profile = true

    # Create a LogWindow; necessary for real-time event updates
    lw = TimespanLogging.Events.LogWindow(20*10^9, :core)
    ml.aggregators[:logwindow] = lw

    # Create the D3Renderer server on port 8080
    d3r = DaggerWebDash.D3Renderer(8080)

    ## Add some plots! Rendered top-down in order

    # Show an overview of all generated events as a Gantt chart
    push!(d3r, DaggerWebDash.GanttPlot(:core, :id, :esat, :psat; title="Overview"))

    # Show various numerical events as line plots over time
    push!(d3r, DaggerWebDash.LinePlot(:core, :wsat, "Worker Saturation", "Running Tasks"))
    push!(d3r, DaggerWebDash.LinePlot(:core, :loadavg, "CPU Load Average", "Average Running Threads"))
    push!(d3r, DaggerWebDash.LinePlot(:core, :bytes, "Allocated Bytes", "Bytes"))
    push!(d3r, DaggerWebDash.LinePlot(:core, :mem, "Available Memory", "% Free"))

    # Show a graph rendering of compute tasks and data movement between them
    # Note: Profile events are ignored if absent from the log
    push!(d3r, DaggerWebDash.GraphPlot(:core, :id, :timeline, :profile, "DAG"))

    # TODO: Not yet functional
    #push!(d3r, DaggerWebDash.ProfileViewer(:core, :profile, "Profile Viewer"))

    # Add the D3Renderer as a consumer of special events generated by LogWindow
    push!(lw.creation_handlers, d3r)
    push!(lw.deletion_handlers, d3r)

    # D3Renderer is also an aggregator
    ml.aggregators[:d3r] = d3r

    ctx.log_sink = ml
end

function configure_LocalEventLog()
    TimespanLogging = Dagger.TimespanLogging
    ctx = Dagger.Sch.eager_context()
    log = TimespanLogging.LocalEventLog()
    ctx.log_sink = log
end

function set_log_file(file_path)
    ctx = Dagger.Sch.eager_context()
    ctx.log_file = file_path
end

function timestamp_string(str)
    dt = Dates.now()
    timestamp = Dates.format(dt, "yyyy-mm-dd HH-MM-SS")
    return str * " " * timestamp
end

function fetch_LocalEventLog()
    ctx = Dagger.Sch.eager_context()
    logs = Dagger.TimespanLogging.get_logs!(ctx.log_sink)
    # str = Dagger.show_plan() - doesn't work (exist)   
    return logs 
end